####### sync.fg


import '../ui'
import '../mesh'


host = '127.0.0.1'
port = 1999


Sync = [

    'writing' : [],
    'sending' : [],
    'offset'  : [],

    'init' : function(self, ctx, dir, mesh)

        watched = dir + '/'

        # clear directory for testing
        sys.rm(watched)
        sys.mkdir(watched)

        self.ctx = ctx
        self.watched = watched
        mesh.ctx = mesh.ctx + [self]
        self.mesh = mesh

        self.files = self.local_snapshot()

        self.mesh.print('file_listen on ' + dir)
        sys.file_listen(watched, self)   # listen for file changes

        return self

    end,

    'greet' : function(self)
        return ['files' : self.files]
    end,

    'local_snapshot' : function(self)

        list = sys.file_list(self.watched) - self.watched
        normalized = [(f-self.watched):list[f] for f in list where not self.ignore(f)]
        return normalized

    end,

    'ignore' : function(self, path)

        i = path.find('/', -1)                  # get last path component
        return (i >= 0) and (path[i+1] == '.')  # ignore files that match ".*"

    end,

    'handle_message' : function(self, socket, msgs4)

        if msgs4.event == 'greet' then
            self.snapshot = msgs4.files

        else if msgs4.event == 'change' then
            self.handle_change(socket, msgs4)

        else if msgs4.event == 'content' then
            self.handle_content(msgs4.path, msgs4.content, msgs4.modified, msgs4.offset)

        else if msgs4.event == 'test' then
            self.handle_test(msgs4)
        end

    end,

    'handle_content' : function(self, path, content, modified, offset)

        # self.mesh.print('handle_content ' + path +' '+ offset)

        self.writing[path] = true

        path = self.watched + path
        if not offset then sys.rm(path) end

        sys.write(path, content, offset)

        self.writing[path] = nil

        self.files = self.local_snapshot()
        if self.ctx.ui then
            sys.ui_set(self.ctx.ui.files, self.files.keys)            # update ui
        end
    end,

    'filed' : function(self, dir)

        #self.mesh.print('filed ' + dir)

        # check for new and deleted files
        latest = self.local_snapshot()
        updated = latest - self.files
        deleted = self.files - latest

        #sys.print('latest=' +latest  +', self.files='+self.files)
        #sys.print('updated='+updated +', deleted='   +deleted)

        # check for files with new mod times
        for f in self.files where (f != self.writing)
            g = self.files[f]
            mod = g.modified
            h = latest[f]
            if h and (mod != h.modified) then
                updated = updated + f:g
            end
        end

        if deleted.keys.length then
            changes = ['deleted' : deleted]
            msg2 = ['event' : 'change', 'changes' : changes]
            self.mesh.broadcast(msg2)
        end

        # add content of each new or modified file
        for u in updated.keys
            self.send_file(u)
        end

        self.files = latest

    end,

    # send a file in chunks
    'send_file' : function(self, path)

        self.mesh.print('send_file ' + path +' '+ self.offset[path])

        self.offset[path] = 0
        if self.sending[path] then return end
        self.sending[path] = true

        msg7 = ['event' : 'content', 'path' : path]

        chunk = 1000    # chunk size in number of bytes
        full_local_path = self.watched + path

        while true

            if (bytes = sys.read(full_local_path, self.offset[path], chunk))
                size,mod = sys.fileattr(full_local_path)
                msg7.content = bytes
                msg7.modified = mod
                msg7.offset = self.offset[path]

                self.offset[path] = self.offset[path] + bytes.length

                #sys.print('send chunk ' + offset)
                self.mesh.broadcast(msg7)
                sys.sleep(500) # to facilitate TC 2 test only

            end

            if bytes.length < chunk then
                self.offset[path] = self.sending[path] = nil
                return
            end
        end

    end,

    'handle_change' : function(self, socket, msg8)

        # delete removed directories and files
        for path in msg8.changes.deleted
            sys.rm(self.watched + path)
        end

    end,

    ####### test

    'handle_test' : function(self, msg7)

        action = msg7.action
        path = self.watched + msg7.path
        status = 'done'

        self.mesh.print('test directive ' + action +': '+ msg7)

        if action == 'update' then
            # sys.mkdir(path)
            sys.write(path, msg7.content)

        else if action == 'rename' then
            sys.move(path, self.watched + msg7.path2)

        else if action == 'delete' then
            sys.rm(path)

        else if action == 'verify' then
            #self.mesh.print('verify ' + path)
            if msg7.size then
                match = msg7.size == sys.fileattr(path)
                #self.mesh.print('size match ' + sys.fileattr(path) +' => '+ match)
            else
                match = msg7.content == sys.read(path)
                self.mesh.print('content match = ' + match)
            end

            if match then status='pass' else status='fail' end

        else if action == 'offline' then
            self.offline = true
        else if action == 'online' then
            self.offline = true
            self.connected()

        else if action == 'die' then
            sys.exit(0)

        else
            status = 'fail: unknown action ' + action
        end
    
        #self.mesh.print('result for ' + action +': '+ status)

        msg8 = ['event' : 'test', 'status' : status, 'seq' : msg7.seq, 'to' : msg7.from]
        self.mesh.send_to(msg7.from, msg8)

    end
]
