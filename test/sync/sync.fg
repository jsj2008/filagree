####### sync.fg


import '../ui'
import '../mesh'


host = '127.0.0.1'
port = 1999


Sync = [

    'sending' :        [],
    'offset'  :        [],
    'remote_version' : [],
    'guidnum' :         1,

    'init' : function(self, view, dir, mesh)

        self.view = view
        self.mesh = mesh
        mesh.subscribe(self)

        self.watched = dir + '/'

        # clear directory for testing
        sys.rm(self.watched)
        sys.mkdir(self.watched)

        self.tmpdir = self.watched +'../tmp/' + self.mesh.id +'/'
        sys.rm(self.tmpdir)
        sys.mkdir(self.tmpdir)

        self.load_db(mesh.id)

        sys.file_listen(self.watched, self)   # listen for file changes

        return self

    end,

    'load_db' : function(self, id)

        self.files = sys.load('../' + id + 'guids') or []           # guid -> [path,version,modified]
        self.guids = [v.path : guid for guid,v in self.guids]
        self.reconcile_local()

    end,


    'local_snapshot' : function(self)

        list = sys.file_list(self.watched) - self.watched           # remove root element
        return [(path - self.watched):attr for path,attr in list]   # make paths relative

    end,

    'greet' : function(self)
        return ['files' : self.files]
    end,

    # returns true if path should be ignored in file events
    'ignore' : function(self, path)
        slash = path.find('/', -1)                      # get last path component
        return (slash >= 0) and (path[slash+1] == '.')  # ignore files that match ".*"
    end,

    # splits on last dot in path
    'extension' : function(self, path)
        dot = path.find('.', -1)                    # get last dot
        pre = path.part(0,dot)
        suf = path.part(dot+1)
        return pre,suf
    end,

    'handle_message' : function(self, socket, msgs4)

        # self.mesh.print('handle_message ' + msgs4)

        if msgs4.event == 'test' then
            self.handle_test(msgs4)
            return
        end

        if self.offline then
            self.mesh.print('(offline)')
            return
        end

        if msgs4.event == 'greet' then
            self.handle_greet(msgs4)

        else if msgs4.event == 'delete' then
            self.handle_delete(msgs4.deletes)

        else if msgs4.event == 'content' then
            self.handle_content(msgs4)
        end
    end,

    # returns true if I need to send guid-file to peer
    'give' : function(self, guid, remote_files)
    
        remote = remote_files[guid]
        if not remote then return false end
        local = self.files[guid]
        return (remote.version < local.version) or
               (remote.by != local.by)
    end,

    'handle_greet' : function(self, msgg)

        self.mesh.print('handle_greet:' + msgg)
        if not msgg.files then return end

        give = [guid for guid in self.files where self.give(guid, msgg.files)]
        self.mesh.print('hg sf='+ self.files +'    give='+ give)
        for i in give
            self.send_file(i, msgg.from)
        end

        self.filed() # check for offline updates

    end,

    # test.txt -> text.fred_123.txt
    'shunt' : function(self, path, by, version)
        pre,suf = self.extension(path)
        tag = '.'+ by +'_v'+ version +'.'
        #self.mesh.print('shunt '+ path+','+from+' -- '+pre+','+tag+','+suf+' returns ' + pre+tag+suf)
        return pre + tag + suf
    end,

    # check for and handle conflicts between local and incoming files
    'conflict_resolution' : function(self, local, incoming, tmppath, fullpath)
        if not local then return end

        # there is a conflict if local and remote versions are both currently higher than the last sync
        prior_remote_version = self.remote_version[incoming.guid]
        conflict = (local.version > prior_remote_version) or
                   ((local.version == incoming.version) and (local.by != incoming.by))
        self.mesh.print('cr ' + conflict +' prv='+prior_remote_version +' iv='+incoming.version + ' local='+local)
        if not conflict then return end # no conflict

        size,lmod = sys.fileattr(fullpath)  # local modified time
        rmod = incoming.modified            # mod time of arriving file

        self.mesh.print('conflict: ' + incoming.guid +', rv=' + incoming.modified +
                        ', prv='+ prior_remote_version +', lv=' + local.version +
                        ' -- lmod='+ lmod+',rmod='+rmod)

        if sys.alert then
            message = 'There is a conflict for ' + local.path + '. Keep yours?'
            mine_wins = sys.alert('Conflict', message)
            self.mesh.print('mine_wins='+mine_wins)
        else
            mine_wins = lmod > rmod
        end

        if mine_wins then
            self.mesh.print('my change wins')
            shunted = self.shunt(fullpath, incoming.by, incoming.version)
            sys.mv(tmppath, shunted, incoming.modified) # move from downloading directory to intended destination
            self.update_ui()
            return true
        end

        self.mesh.print('my change loses')
        victim = self.watched + local.path
        shunted = self.shunt(victim, self.mesh.id, local.version)
        sys.mv(victim, shunted, local.modified)
        return false

    end,

    # handle incoming file (or piece thereof)
    'handle_content' : function(self, incoming)

        tmppath = self.tmpdir + incoming.path
        if (not incoming.offset) then sys.rm(tmppath) end
        sys.write(tmppath, incoming.content, incoming.offset)
        if not incoming.last then return end # more to come later

        guid,path = incoming.guid,incoming.path
        fullpath = self.watched + path
        local = self.files[guid]

        self.mesh.print('received ' + path +' v'+ incoming.version +', by '+incoming.by)
        if self.conflict_resolution(local, incoming, tmppath, fullpath) then return end

        self.files[guid] = ['path':path, 'modified':incoming.modified, 'updating':incoming.modified, 'version':incoming.version, 'by':incoming.by]
        self.guids[path] = guid
        self.remote_version[guid] = incoming.version
        sys.mv(tmppath, fullpath, incoming.modified) # move from downloading directory to intended destination
        self.update_ui()

    end,


    # called when the OS detects a file change, sends out updates/deletes
    'filed' : function(self, dir)

        updates,deletes = self.reconcile_local()

        if self.offline then
            self.meanwhile = ['updates':updates, 'deletes':deletes]
            return
        else if self.meanwhile then
            updates,deletes = self.meanwhile.updates, self.meanwhile.deletes
            self.meanwhile = nil
        end
        #self.mesh.print('filed: updates=' + updates)

        for u in updates
            self.send_file(u)
        end

        if deletes.length then
            #self.mesh.print('deletes='+deletes)
            msg2 = ['event' : 'delete', 'deletes' : deletes]
            self.mesh.broadcast(msg2)
        end

        self.update_ui()

    end,


    # figure out what updated/deleted on local device
    'reconcile_local' : function(self)

        updates = []
        files = self.local_snapshot()   # path -> attributes
        #self.mesh.print('files=' + files)

        for path in files

            fsfile = files[path]        # [modified,dir]
            fsmod = fsfile.modified
            guid = self.guids[path]

            #self.mesh.print('reconcile_local: ' + path + ' guid=' + guid)

            if not guid then            # new file

                guid = self.mesh.id +'_'+ path +'_'+ self.guidnum
                self.files[guid] = (['path':path, 'version':1] + fsfile)
                self.guids[path] = guid
                ++self.guidnum
                updates = updates + guid
                self.files[guid].by = self.mesh.id # most recent author c'est moi

            else                        # updated file

                dbfile = self.files[guid] # last known local metadata
                dbmod = dbfile.modified

                self.mesh.print(path + ' : ' + guid + ' fsmod='+fsmod+', dbmod='+dbmod+', dbfile.updating='+dbfile.updating)
                if (fsmod != dbmod) and (fsmod != dbfile.updating) then # offline update
                    self.mesh.print('update '+ guid +' to v'+ self.files[guid].version)
                    ++self.files[guid].version
                    updates = updates + guid
                    self.files[guid].by = self.mesh.id
                end
                dbfile.updating = nil
                dbfile.modified = fsmod
            end

        end

        deletes = [guid for path,guid in self.guids where (not files[path])]
        #self.mesh.print('reconcile_local: guids='+self.guids+', files='+self.files)

        return updates, deletes
    end,


    # send a file in chunks
    'send_file' : function(self, guid, to)

        file = self.files[guid]
        path, version, by = file.path, file.version, file.by

        self.offset[path] = 0
        if self.sending[path] then return end
        self.sending[path] = true

        full_local_path = self.watched + path
        size,mod = sys.fileattr(full_local_path)
        msg7 = ['event':'content', 'path':path, 'guid':guid, 'version':version, 'by':by, 'modified':mod]

        chunk = 10000    # chunk size in number of bytes

        while true

            if (bytes = sys.read(full_local_path, self.offset[path], chunk)) # non-zero
                msg7.content = bytes
                msg7.offset = self.offset[path]
                msg7.last = (bytes.length < chunk) # eom
                self.offset[path] = self.offset[path] + bytes.length
                if (to) then
                    self.mesh.send_to(to, msg7)
                else
                    self.mesh.broadcast(msg7) # send to everyone
                end

                if self.slowdown then sys.sleep(500) end # to facilitate TC2
            end

            if bytes.length < chunk then # last chunk
                msg7.last = true
                self.offset[path] = self.sending[path] = nil
                self.remote_version[guid] = version
                self.mesh.print('sent ' + guid +' v'+ version +', by '+ by +', to '+(to or 'all'))
                return # exit from loop
            end
        end
    end,

    'handle_delete' : function(self, deletes)

        #self.mesh.print('handle_delete ' + deletes)

        # delete removed directories and files
        for guid in deletes
            path = self.files[guid].path
            #self.mesh.print('deletn ' + path + ', self.files='+self.files)
            self.files[guid].deleting = true
            sys.rm(self.watched + path)
        end

    end,

    'update_ui' : function(self)
        if self.view then
            paths = [self.watched + p for p in self.guids.keys]
            self.view.update_view(paths)
        end
    end,

    ####### test

    'handle_test' : function(self, msg7)

        action = msg7.action
        path = self.watched + msg7.path
        status = 'done'

        if not msg7.retry then self.mesh.print('test ' + msg7.seq  +': '+ msg7) end

        if action == 'update' then
            # sys.mkdir(path)
            sys.write(path, msg7.content)

        else if action == 'rename' then
            size,mod = sys.fileattr(path)
            sys.mv(path, self.watched + msg7.path2, mod)

        else if action == 'delete' then
            sys.rm(path)

        else if action == 'verify' then
            #self.mesh.print('verify ' + path)
            if msg7.size then
                match = msg7.size == sys.fileattr(path)
                #self.mesh.print('size match ' + sys.fileattr(path) +' => '+ match)
            else
                match = msg7.content == sys.read(path)
                #self.mesh.print('content match = ' + match)
            end

            if match then status='pass' else status='fail' end
            #self.mesh.print('match=' + match)

        else if action == 'offline' then
            self.offline = true
        else if action == 'online' then
            sys.print('\n\n')
            self.offline = nil
            self.mesh.connected()

        else if action == 'die' then
            sys.sleep(1000) # wait for broadcast to go out
            self.mesh.print('exiting')
            sys.exit(0)

        else
            status = 'fail: unknown action ' + action
        end

        #self.mesh.print('result for ' + action +': '+ status)

        msg8 = ['event' : 'test', 'status' : status, 'seq' : msg7.seq, 'to' : msg7.from]
        self.mesh.send_to(msg7.from, msg8)

    end
]
