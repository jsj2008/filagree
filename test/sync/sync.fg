####### sync.fg


import '../ui'
import '../mesh'


host = '127.0.0.1'
port = 1999


Sync = [

    'writing' : [],

    'init' : function(self, ctx, dir, mesh)

        watched = dir + '/'

        # clear directory for testing
        sys.rm(watched)
        sys.mkdir(watched)

        self.ctx = ctx
        self.watched = watched
        mesh.ctx = mesh.ctx + [self]
        self.mesh = mesh

        self.files = self.local_snapshot()

        sys.file_listen(watched, self)   # listen for file changes

        return self

    end,

    'greet' : function(self)
        return ['files' : self.files]
    end,

    'local_snapshot' : function(self)

        list = sys.file_list(self.watched) - self.watched
        normalized = [(f-self.watched):list[f] for f in list where not self.ignore(f)]
        return normalized

    end,

    'ignore' : function(self, path)

        i = path.find('/', -1)                  # get last path component
        return (i >= 0) and (path[i+1] == '.')  # ignore files that match ".*"

    end,

    'handle_message' : function(self, socket, msg4)

        if msg4.event == 'greet' then
            self.snapshot = msg4.files

        else if msg4.event == 'change' then
            self.handle_change(socket, msg4)

        else if msg4.event == 'content' then
            self.handle_content(msg4.path, msg4.content, msg4.modified, msg4.offset)

        else if msg4.event == 'test' then
            self.handle_test(msg4)
        end

    end,

    'handle_content' : function(self, path, content, modified, offset)

        self.writing[path] = true

        path = self.watched + path
        if not offset then sys.rm(path) end
        sys.write(path, content, offset)

        self.writing[path] = nil
        self.files = self.local_snapshot()
        if self.ctx.ui then
            sys.ui_set(self.ctx.ui.files, self.files.keys)            # update ui
        end
    end,

    'filed' : function(self, dir)

        # check for new and deleted files
        latest = self.local_snapshot()
        updated = latest - self.files
        deleted = self.files - latest

        #sys.print('latest=' +latest  +', self.files='+self.files)
        #sys.print('updated='+updated +', deleted='   +deleted)

        # check for files with new mod times
        for f in self.files where (f != self.writing)
            g = self.files[f]
            mod = g.modified
            h = latest[f]
            if h and (mod != h.modified) then
                updated = updated + f:g
            end
        end

        if deleted.keys.length then
            changes = ['deleted' : deleted]
            msg2 = ['event' : 'change', 'changes' : changes]
            self.mesh.broadcast(msg2)
        end

        # add content of each new or modified file
        for u in updated.keys
            self.send_file(u)
        end

        self.files = latest

    end,

    # send a file in chunks
    'send_file' : function(self, path)

        msg7 = ['event' : 'content', 'path' : path]

        chunk = 100    # chunk size in number of bytes
        offset = 0
        path = self.watched + path

        while true

            if (bytes,mod = sys.read(path, offset, chunk))
                msg7.content = bytes
                msg7.modified = mod
                msg7.offset = offset

                offset = offset + bytes.length

                #sys.print('send chunk ' + offset)
                self.mesh.broadcast(msg7)

            end
            if bytes.length < chunk then return end
        end

    end,

    'handle_change' : function(self, socket, msg8)

        # delete removed directories and files
        for path in msg8.changes.deleted
            sys.rm(self.watched + path)
        end

    end,

    ####### test

    'handle_test' : function(self, msg7)

        sys.print(self.mesh.id + ' -- test directive: ' + msg7)

        action = msg7.action
        path = self.watched + msg7.path
        status = 'done'

        if action == 'update' then
            # sys.mkdir(path)
            sys.write(path, msg7.content)

        else if action == 'rename' then
            sys.move(path, self.watched + msg7.path2)

        else if action == 'delete' then
            sys.rm(path)

        else if action == 'verify' then
            content = sys.read(path)
            if content == msg7.content then
                status = 'pass'
            else
                status = 'fail: ' + content +' != '+ msg7.content
            end

        else if action == 'offline' then
            self.offline = msg7.offline
            if not msg7.offline then
                self.connected()
            end

        else if action == 'die' then
            sys.exit(0)
        end

        msg8 = ['event' : 'test', 'status' : status, 'seq' : msg7.seq, 'to' : msg7.from]
        self.mesh.send_to(msg7.from, msg8)

    end
]
