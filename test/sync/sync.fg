####### sync.fg

port = 9999
test_dir   = 'synctest/'


Sync = [

    'init' : function(self, ctx, watched, id)

        self = ['ctx':ctx, 'watched':watched, 'id':id, 'peers':[]] + self
        self.files = self.local_snapshot()
        if ctx and ctx.ui then
            sys.ui_set(ctx.ui.files, self.files.keys)     # update ui
        end
        return self

    end,

    'local_snapshot' : function(self)

        list = sys.file_list(self.watched) - self.watched
        normalized = [(f-self.watched):list[f] for f in list where not self.ignore(f)]
        return normalized

    end,

    'ignore' : function(self, path)

        i = path.find('/', -1)                  # get last path component
        return (i >= 0) and (path[i+1] == '.')  # ignore files that match ".*"

    end,

    'connected' : function(self, socket)

        msg1 = ['event' : 'greet', 'id' : self.id, 'files' : self.files]
        if socket then
            sys.send(socket, msg1)
        else
            self.broadcast(msg1)
        end
    end,

    'messaged' : function(self, socket, msg4)

        sys.print('message from ' + socket + ': ' + msg4)

        if msg4.event == 'content-request' then
            self.handle_content_request(socket, msg4)

        else if msg4.event == 'greet' then
            self.peers[msg4.id] = socket
            self.snapshot = msg4.files

        else if msg4.event == 'change' then
            self.handle_change(socket,msg4.changes)

        else if msg4.event == 'content' then
            self.writing = msg4.path
            sys.write(self.watched + msg4.path, msg4.content)   # save file
            self.writing = nil
            files = self.local_snapshot().keys
            if self.ctx.ui then
                sys.ui_set(self.ctx.ui.files, files)            # update ui
            end

        else if msg4.event = 'test' then
            self.handle_test(msg4)
        end

    end,

    'handle_content_request' : function(self, socket, msg5)

        for path in msg5.paths

            fullpath = self.watched + path
            content = sys.read(fullpath)
            response = ['event' : 'content', 'path' : path, 'content' : content]
            sys.send(socket, response)

        end
    end,

    'filed' : function(self, path)

        if path == self.writing # because we're writing to it
            return
        end
        latest = self.local_snapshot()
        updated = latest - self.files
        deleted = self.files - latest
        for f in self.files
            g = self.files[f]
            mod = g.modified
            h = latest[f]
            if h and (mod != h.modified) then
                updated = updated + f:g
            end
        end

        changes = ['updated' : updated, 'deleted' : deleted]

        msg2 = ['event' : 'change', 'changes' : changes]
        self.broadcast(msg2)
        self.files = latest

    end,

    'handle_change' : function(self, socket, changez)

        cu = changez.updated
        cd = changez.deleted

        # create new directories
        for path in cu where cu[path].dir
            sys.mkdir(self.watched + path)
        end

        # delete removed directories and files
        for path in cd
            sys.remove(self.watched + path)
        end

        # request update file bodies
        self.snapshot = self.snapshot + cu - cd
        paths = [path for path in cu where not cu[path].dir]
        if paths.length then
            msg3 = ['event' : 'content-request', 'paths' : paths]
            sys.send(socket, msg3)
        end

    end,

    'broadcast' : function(self, msg6)
        if self.offline then
            return
        end
        for socket in self.peers.vals
            sys.send(socket, msg6)
        end
    end,

    ####### test

    'handle_test' : function(self, msg7)
        if msg7.id then
            sys.print('self.peers = ' + self.peers)
            socket = self.peers[msg7.id]
            sys.print('send test to ' + msg7.id + ' - ' + socket)
            msg7.id = nil
            sys.send(socket, msg7)
        else
            sys.print('test directive: ' + msg7.directive)
            sys.interpret(msg7.directive)
        end
    end,

    'test_set_offline' : function(self, off)
        self.offline = of
        if not off then
            self.connected()
        end
    end,

    'test_file_update' : function(self, path, content)
        sys.write(self.watched + path, content)
    end,

    'test_file_move' : function(self, from, to)
        sys.rename(from, to)
    end,

    'test_file_read' : function(self, path)
        return sys.read(self.watched + path)
    end,

    'test_file_delete' : function(self, path)
        sys.remove(self.watched + path)
    end,

]

sys.mkdir(test_dir)

empty = function(dir)
    sys.remove(dir)
    sys.mkdir(dir)
end
