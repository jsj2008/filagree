####### sync.fg


import '../ui'
import '../mesh'


host = '127.0.0.1'
port = 1999


Sync = [

    'sending' : [],
    'offset'  : [],
    'guidnum' : 1,

    'init' : function(self, view, dir, mesh)

        self.view = view
        self.mesh = mesh
        mesh.subscribe(self)

        self.watched = dir + '/'

        # clear directory for testing
        sys.rm(self.watched)
        sys.mkdir(self.watched)

        self.tmpdir = self.watched +'../tmp/' + self.mesh.id +'/'
        sys.rm(self.tmpdir)
        sys.mkdir(self.tmpdir)

        self.load_db(mesh.id)

        sys.file_listen(self.watched, self)   # listen for file changes

        return self

    end,

    'load_db' : function(self, id)

        self.files = sys.load('../' + id + 'guids') or []           # guid -> [path,version,modified]
        self.guids = [v.path : guid for guid,v in self.guids]
        self.reconcile_local()

    end,


    'local_snapshot' : function(self)

        list = sys.file_list(self.watched) - self.watched           # remove root element
        return [(path - self.watched):attr for path,attr in list]   # make paths relative

    end,

    'greet' : function(self)
        return ['files' : self.files]
    end,


    'ignore' : function(self, path)

        i = path.find('/', -1)                  # get last path component
        return (i >= 0) and (path[i+1] == '.')  # ignore files that match ".*"

    end,

    'handle_message' : function(self, socket, msgs4)

        # self.mesh.print('handle_message ' + msgs4)

        if msgs4.event == 'test' then
            self.handle_test(msgs4)
            return
        end

        if self.offline then
            self.mesh.print('(offline)')
            return
        end

        if msgs4.event == 'greet' then
            self.handle_greet(msgs4)

        else if msgs4.event == 'delete' then
            self.handle_delete(msgs4.deletes)

        else if msgs4.event == 'content' then
            self.handle_content(msgs4)

        else if msgs4.event == 'test' then
            self.handle_test(msgs4)
        end
    end,

    'handle_greet' : function(self, msgg)

        # sys.print('handle_greet:' + msgg)
        if not msgg.files then return end

        give = self.files - msgg.files
        for i in give
            self.send_file(i)
        end

        for j in msgg.files where j.deletes
            path = self.guids[j.guid].path
            sys.rm(path)
        end

    end,

    'handle_content' : function(self, msgc4)
    
        guid, path, content, modified, offset, last = msgc4.guid, msgc4.path, msgc4.content, msgc4.modified, msgc4.offset, msgc4.last

        tmppath = self.tmpdir + path
        if (not offset) then sys.rm(tmppath) end

        sys.write(tmppath, content, offset)

        #self.mesh.print('handle_content ' + msgc4)

        if last then

            fullpath = self.watched + path
            self.mesh.print('mv ' + fullpath + ' ' + modified)
            sys.mv(tmppath, fullpath, modified)

            self.files[msgc4.guid] = ['path':path, 'modified':modified, 'updating':modified]
            self.guids[path] = guid # todo: check for conflict
            self.mesh.print('last - self.files['+msgc4.guid+']='+ self.files[msgc4.guid])

            self.update_ui()
        end

    end,

    # called when the OS detects a file change, sends out updates/deletes
    'filed' : function(self, dir)

        if self.offline then
            return
        end

        self.mesh.print('filed')

        updates,deletes = self.reconcile_local()

        for u in updates
            self.send_file(u)
        end

        if deletes.length then
            #self.mesh.print('deletes='+deletes)
            msg2 = ['event' : 'delete', 'deletes' : deletes]
            self.mesh.broadcast(msg2)
        end

        self.update_ui()

    end,


    # figure out what updated/deleted on local device
    'reconcile_local' : function(self)

        updates = []
        files = self.local_snapshot()   # path -> attributes

        for path in files

            fsfile = files[path]        # [modified,dir]
            fsmod = fsfile.modified
            guid = self.guids[path]

            #self.mesh.print('reconcile_local: ' + path + ' guid=' + guid)

            if not guid then            # new file

                guid = self.mesh.id +'_'+ path # self.guidnum
                self.files[guid] = (['path':path, 'version':0] + fsfile)
                self.guids[path] = guid
                ++self.guidnum
                updates = updates + guid

            else 
            
                dbfile = self.files[guid]
                dbmod = dbfile.modified
                
                if (fsmod != dbmod) and (fsmod != dbfile.updating) then # offline update
                    ++self.files[guid].version
                    updates = updates + guid
                end
            end
        end

        deletes = [guid for path,guid in self.guids where (not files[path])]
        self.mesh.print('guids='+self.guids+', files='+files+', deletes='+deletes)

        return updates, deletes
    end,


    # send a file in chunks
    'send_file' : function(self, guid)

        #self.mesh.print('files='+self.files[guid])
        path = self.files[guid].path

        self.offset[path] = 0
        if self.sending[path] then return end
        self.sending[path] = true

        msg7 = ['event':'content', 'path':path, 'guid':guid]

        chunk = 10000    # chunk size in number of bytes
        full_local_path = self.watched + path

        while true

            if (bytes = sys.read(full_local_path, self.offset[path], chunk))
                size,mod = sys.fileattr(full_local_path)
                msg7.content = bytes
                msg7.modified = mod
                msg7.offset = self.offset[path]
                msg7.last = (bytes.length < chunk)

                self.offset[path] = self.offset[path] + bytes.length

                self.mesh.print('send ' + path +' '+ mod)

                self.mesh.broadcast(msg7)
                
                if self.slowdown then sys.sleep(500) end # to facilitate TC2
            end

            if bytes.length < chunk then
                self.offset[path] = self.sending[path] = nil
                return
            end
        end

    end,

    'handle_delete' : function(self, deletes)

        #self.mesh.print('handle_delete ' + deletes)

        # delete removed directories and files
        for guid in deletes
            path = self.files[guid].path
            #self.mesh.print('deletn ' + path + ', self.files='+self.files)
            self.files[guid].deleting = true
            sys.rm(self.watched + path)
        end

    end,

    'update_ui' : function(self)
        if self.view then
            self.view.set_files(self.files.keys)
        end
    end,

    ####### test

    'handle_test' : function(self, msg7)

        action = msg7.action
        path = self.watched + msg7.path
        status = 'done'

        if not msg7.retry then self.mesh.print('test ' + msg7.seq  +': '+ msg7) end

        if action == 'update' then
            # sys.mkdir(path)
            sys.write(path, msg7.content)

        else if action == 'rename' then
            size,mod = sys.fileattr(path)
            sys.mv(path, self.watched + msg7.path2, mod)

        else if action == 'delete' then
            sys.rm(path)

        else if action == 'verify' then
            #self.mesh.print('verify ' + path)
            if msg7.size then
                match = msg7.size == sys.fileattr(path)
                #self.mesh.print('size match ' + sys.fileattr(path) +' => '+ match)
            else
                match = msg7.content == sys.read(path)
                #self.mesh.print('content match = ' + match)
            end

            if match then status='pass' else status='fail' end

        else if action == 'offline' then
            self.offline = true
        else if action == 'online' then
            self.offline = nil
            self.mesh.connected()

        else if action == 'die' then
            sys.sleep(1000) # wait for broadcast to go out
            sys.exit(0)

        else
            status = 'fail: unknown action ' + action
        end
    
        #self.mesh.print('result for ' + action +': '+ status)

        msg8 = ['event' : 'test', 'status' : status, 'seq' : msg7.seq, 'to' : msg7.from]
        self.mesh.send_to(msg7.from, msg8)

    end
]
