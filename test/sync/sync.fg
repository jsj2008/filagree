####### sync.fg


import '../ui'
import '../mesh'


host = '127.0.0.1'
port = 1999


Sync = [

    'writing' : [],
    'sending' : [],
    'offset'  : [],
    'guidnum' : 0,

    'init' : function(self, view, dir, mesh)

        self.watched = dir + '/'

        # clear directory for testing
        sys.rm(self.watched)
        sys.mkdir(self.watched)

        self.view = view
        self.mesh = mesh

        self.load_db()

        sys.file_listen(self.watched, self)   # listen for file changes

        return self

    end,

    'load_db' : function(self)
        self.files = sys.load('../' + mesh.id + 'guids')        # guid -> [path,version,modified]

        self.guids = [self.guids[guid].path : guid for guid in self.guids.keys]

        self.reconcile_local()
    end,

    # figure out what changed on local device
    'reconcile_local' : function(self)

        updated = []
        deleted = []

        files = self.local_snapshot()                           # path -> attributes

        for path in files.keys

            file = files[path]
            guid = self.guids[path]

            if not guid then                                   # new file

                guid = self.guidnum
                self.guids[guid] = ['path' : path,
                                    'version' : 0,
                                    'modified' : file.modified]
                self.guidnum = self.guidnum + 1
                updates = updates + guid

            else

                if file.modified != datum.modified then # offline change detected
                self.increment_version(datum.guid)
                updates = updates + guid
            end
        end

        deleted = [guid for guid in self.guids.vals where not files[self.guids[guid]]]

        rename updated, deleted

    end,

    'increment_version' : function(self, guid)
        self.files[guid].version = self.files[guid].version + 1
    end,

    'greet' : function(self)
        return ['files' : self.files]
    end,

    'guid' : function(self, path)

        self.guid[path] = self.guid[path] or (self.mesh.id + self.guidnum)
        self.guidnum = self.guidnum + 1
        return self.guid[path]

    end,

    'local_snapshot' : function(self)

        list = sys.file_list(self.watched) - self.watched
        result = []
        for f in list where not self.ignore(f)
            path = 'path' : f - self.watched
            guid = self.guid(path)
            result = result + g:(list[f]+version)
        end
        sys.print('local_snapshot: ' + result)
        return result

    end,

    'ignore' : function(self, path)

        i = path.find('/', -1)                  # get last path component
        return (i >= 0) and (path[i+1] == '.')  # ignore files that match ".*"

    end,

    'handle_message' : function(self, socket, msgs4)

        if msgs4.event == 'test' then
            self.handle_test(msgs4)
            return
        end

        if self.offline then
            self.mesh.print('(offline)')
            return
        end

        if msgs4.event == 'greet' then
            self.handle_greet(msgs4)

        else if msgs4.event == 'delete' then
            self.handle_delete(msgs4.deleted)

        else if msgs4.event == 'content' then
            self.handle_content(msgs4)

        else if msgs4.event == 'test' then
            self.handle_test(msgs4)
        end
    end,

    'handle_greet' : function(self, msgg)

        sys.print('handle_greet:' + msgg)
        if not msgg.files then return end

        give = self.files - msgg.files
        for i in i_have.keys
            self.send_file(i)
        end

        for j in msgg.files where j.deleted
            path = self.guids[j.guid].path
            sys.rm(path)
        end

    end,

    'handle_content' : function(self, msgc)
    
        path, content, modified, offset, last = msgc4.path, msgc4.content, msgc4.modified, msgc4.offset, msgc4.last

        # self.mesh.print('handle_content ' + path +' '+ offset)

        tmppath = self.watched +'/../tmp' + self.mesh.id +'/'+ path
        if not offset then sys.rm(tmppath) end

        sys.write(tmppath, content, offset)

        if last then
            sys.mv(tmppath, path)
            self.guids[msgc4.guid] = ['path':path, 'modified':modified]
            self.update_ui()
        end

    end,

    # called when the OS detects a file change
    'filed' : function(self, dir)

        if self.offline then
            return
        end

        latest = self.local_snapshot()

        updated = latest - self.files
        for u in updated
            self.send_file(u)
        end

        deleted = self.files - latest
        if deleted.keys.length then
            msg2 = ['event' : 'delete', 'delete' : deleted]
            self.mesh.broadcast(msg2)
        end

        self.files = latest
        self.update_ui()

    end,

    # send a file in chunks
    'send_file' : function(self, path)

        self.offset[path] = 0
        if self.sending[path] then return end
        self.sending[path] = true

        msg7 = ['event' : 'content', 'path' : path]

        chunk = 10000    # chunk size in number of bytes
        full_local_path = self.watched + path

        while true

            if (bytes = sys.read(full_local_path, self.offset[path], chunk))
                size,mod = sys.fileattr(full_local_path)
                msg7.content = bytes
                msg7.modified = mod
                msg7.offset = self.offset[path]
                msg7.last = (bytes.length < chunk)

                self.offset[path] = self.offset[path] + bytes.length

                #sys.print('send chunk ' + offset)
                self.mesh.broadcast(msg7)
                
                if self.slowdown then
                    sys.sleep(500) # to facilitate TC2
                end

            end

            if bytes.length < chunk then
                self.offset[path] = self.sending[path] = nil
                return
            end
        end

    end,

    'handle_delete' : function(self, deleted)

        sys.print('handle_delete ' + deleted)

        # delete removed directories and files
        for guid in deleted.keys
            path = self.guids[guid]
            sys.rm(self.watched + path)
        end

    end,

    'update_ui' : function(self)
        if self.view then
            self.view.set_files(self.files.keys)
        end
    end,

    ####### test

    'handle_test' : function(self, msg7)

        action = msg7.action
        path = self.watched + msg7.path
        status = 'done'

        # if not msg7.retry then
        #    self.mesh.print('test ' + msg7.seq  +': '+ msg7)
        # end

        if action == 'update' then
            # sys.mkdir(path)
            sys.write(path, msg7.content)

        else if action == 'rename' then
            sys.move(path, self.watched + msg7.path2)

        else if action == 'delete' then
            sys.rm(path)

        else if action == 'verify' then
            #self.mesh.print('verify ' + path)
            if msg7.size then
                match = msg7.size == sys.fileattr(path)
                #self.mesh.print('size match ' + sys.fileattr(path) +' => '+ match)
            else
                match = msg7.content == sys.read(path)
                #self.mesh.print('content match = ' + match)
            end

            if match then status='pass' else status='fail' end

        else if action == 'offline' then
            self.offline = true
        else if action == 'online' then
            self.offline = nil
            self.mesh.connected()

        else if action == 'die' then
            sys.exit(0)

        else
            status = 'fail: unknown action ' + action
        end
    
        #self.mesh.print('result for ' + action +': '+ status)

        msg8 = ['event' : 'test', 'status' : status, 'seq' : msg7.seq, 'to' : msg7.from]
        self.mesh.send_to(msg7.from, msg8)

    end
]
