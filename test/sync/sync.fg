####### sync.fg

Sync = [

    'writing' : [],

    'init' : function(self, ctx, dirs, mesh)

        watched = dirs[0] + '/' # todo: watch all dirs

        # clear directory for testing
        sys.rm(watched)
        sys.mkdir(watched)

        self.ctx = ctx
        self.watched = watched
        mesh.ctx = mesh.ctx + [self]
        self.mesh = mesh

        self.files = self.local_snapshot()

        if ctx and ctx.ui then
            sys.ui_set(ctx.ui.files, self.files.keys) # update ui
        end

        sys.file_listen(watched, self)   # listen for file changes

        return self

    end,

    'greet' : function(self)
        return ['files' : self.files]
    end,

    'local_snapshot' : function(self)

        list = sys.file_list(self.watched) - self.watched
        normalized = [(f-self.watched):list[f] for f in list where not self.ignore(f)]
        return normalized

    end,

    'ignore' : function(self, path)

        i = path.find('/', -1)                  # get last path component
        return (i >= 0) and (path[i+1] == '.')  # ignore files that match ".*"

    end,

    'handle_message' : function(self, socket, msg4)

        if msg4.event == 'content-request' then
            self.handle_content_request(socket, msg4)

        else if msg4.event == 'greet' then
            self.snapshot = msg4.files

        else if msg4.event == 'change' then
            self.handle_change(socket, msg4)

        else if msg4.event == 'content' then
            self.handle_content(msg4.from, msg4.path, msg4.content, msg4.modified)

        else if msg4.event == 'test' then
            self.handle_test(msg4)
        end

    end,

    'handle_content' : function(self, from, path, content, modified)

        self.writing[path] = ['from':from, 'modified':modified]
        sys.write(self.watched + path, content, modified)   # save file
        files = self.local_snapshot().keys
        if self.ctx.ui then
            sys.ui_set(self.ctx.ui.files, files)            # update ui
        end
    end,

    'handle_content_request' : function(self, socket, msg5)

        for path in msg5.paths

            fullpath = self.watched + path
            content, modified = sys.read(fullpath)
            response = ['event' : 'content', 'path' : path, 'content' : content, 'modified' : modified]
            self.mesh.send(socket, response)

        end
    end,

    'filed' : function(self, path, modified)

        # skip files we're currently writing to
        skip = self.writing[path].modified
        if skip == modified
            sys.print('...same')
            except = self.writing[path].from
            self.writing[path] = nil
            return
        end

        # check for new and deleted files
        latest = self.local_snapshot()
        updated = latest - self.files
        deleted = self.files - latest

        # check for files with new mod times
        for f in self.files
            g = self.files[f]
            mod = g.modified
            h = latest[f]
            if h and (mod != h.modified) then
                updated = updated + f:g
            end
        end

        # add content of each new or modified file
        for u in updated.keys
            updated[u] = updated[u] + 'content':sys.read(self.watched + u)
        end

        if updated.keys.length or deleted.keys.length then
            changes = ['updated' : updated, 'deleted' : deleted]
            msg2 = ['event' : 'change', 'changes' : changes]
            self.mesh.broadcast(msg2)
        end

        self.files = latest

    end,

    'handle_change' : function(self, socket, msg8)

        changez = msg8.changes
        cu = changez.updated
        cd = changez.deleted

        # create new directories
        for path in cu where cu[path].dir
            sys.mkdir(self.watched + path)
        end

        # delete removed directories and files
        for path in cd
            sys.rm(self.watched + path)
        end

        # request update file bodies
        self.snapshot = self.snapshot + cu - cd
        paths = [path for path in cu where not (cu[path].dir or cu[path].content)]
        if paths.length then
            msg3 = ['event' : 'content-request', 'paths' : paths]
            self.mesh.send(socket, msg3)
        end
        for path in cu where cu[path].content
            self.handle_content(msg8.from, path, cu[path].content, cu[path].modified)
        end

    end,

    ####### test

    'handle_test' : function(self, msg7)

        sys.print('test directive: ' + msg7)

        action = msg7.action
        path = self.watched + msg7.path
        status = 'done'

        if action == 'update' then
            sys.write(path, msg7.content)

        else if action == 'move' then
                sys.rename(from, to)

        else if action == 'delete' then
            sys.rm(path)

        else if action == 'offline' then
                self.offline = msg7.offline
                if not msg7.offline then
                    self.connected()
                end

        else if action == 'verify' then
            content = sys.read(path)
            if content == msg7.content then
                status = 'pass'
            else
                status = 'fail: ' + content +' != '+ msg7.content
            end
        end

        msg8 = ['event' : 'test', 'status' : status, 'seq' : msg7.seq, 'to' : msg7.from]
        self.mesh.send_to(msg7.from, msg8)

    end

]
