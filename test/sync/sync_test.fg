####### test_sync.fg

# to run, launch server and two clients, 'client1' and 'client2'


import 'sync' # for host and port
import '../test_director'


director = [

    'run_tests' : function(self)

        #self.crud()
        #self.large()
        self.conflict()
        #self.many()

    end,

    #
    # test to create, rename, update, delete
    #

    'crud' : function(self)

        # create
        self.sync_direct('client1', 'update', 'a.txt', '123')
        self.sync_direct('client1', 'verify', 'a.txt', '123')
        self.sync_direct('server1', 'verify', 'a.txt', '123')
        self.sync_direct('client2', 'verify', 'a.txt', '123')

        # rename
        self.sync_direct('client1', 'rename', 'a.txt', nil, 'b.txt')
        self.sync_direct('client1', 'verify', 'b.txt', '123')
        self.sync_direct('server1', 'verify', 'b.txt', '123')
        self.sync_direct('client2', 'verify', 'b.txt', '123')

        # update
        self.sync_direct('client2', 'update', 'b.txt', '456')
        self.sync_direct('client2', 'verify', 'b.txt', '456')
        self.sync_direct('server1', 'verify', 'b.txt', '456')
        self.sync_direct('client1', 'verify', 'b.txt', '456')

        #delete
        self.sync_direct('client1', 'delete', 'b.txt')
        self.sync_direct('client1', 'verify', 'b.txt')
        self.sync_direct('server1', 'verify', 'b.txt')
        self.sync_direct('client2', 'verify', 'b.txt')

    end,
/*
    #
    # Scalability test
    #
    'many' : function(self)

        servers = 1
        while servers < 10

            clients = 100
            while clients < 10000

                test_cruds(servers, clients)

                clients = clients * 10
            end
            servers = servers + 10
        end
    end,

    'test_cruds(servers, clients)

            pids = []
            c = s = 0

            # fork servers
            while s < servers
                pids[c+s] = sys.forkexec(false, '../../filagree sync_server.fg')
                s = s + 1
            end

            while c < clients
                pids[c+s] = sys.forkexec(false, '../../filagree sync_client.fg \"id=\'' + c + \'\")
                c = c + 1
            end

            test_crud(clients)

    end,

*/

    #
    # Sync & Conflict Resolution - Test Cases
    #

    'conflict' : function(self)

        # TC 1: Simple Edit – Variation 1
        self.sync_direct('server1', 'update', 'tc1.txt', 'tc1a')
        self.sync_direct('client1', 'verify', 'tc1.txt', 'tc1a')
        self.sync_direct('client1', 'update', 'tc1.txt', 'tc1b')
        self.sync_direct('client1', 'verify', 'tc1.txt', 'tc1b')
        self.sync_direct('server1', 'verify', 'tc1.txt', 'tc1b')

        # TC 2: Simple Edit – Variation 2
        dir = 'client1'
        # todo: fix out of order bug
        self.create_local_file(dir, 'tc2', 1024)    # create file that take time to upload
        sys.sleep(2000)                             # wait for client to detect file, and start uploading
        self.create_local_file(dir, 'tc2', 1)       # overwrite with another file
        self.sync_direct('client1', 'verify', 'tc2', nil, nil, 1)
        self.sync_direct('client2', 'verify', 'tc2', nil, nil, 1)
        self.sync_direct('server1', 'verify', 'tc2', nil, nil, 1)

        # etc.

    end,

    #
    # test to transfer large files
    #

    'large' : function(self)

        test_xfer = function(self, size)

            dir = 'client1'
            filename = size + 'B'
            self.create_local_file(dir, filename, size)
            self.sync_direct('client1', 'verify', filename, nil, nil, size)
            self.sync_direct('server1', 'verify', filename, nil, nil, size)
            self.sync_direct('client2', 'verify', filename, nil, nil, size)

        end

        size = 1024 # bytes
        #while size <= (1024*1024) # 1GB
            test_xfer(self, size)
            size = size * 2
        #end

    end,

    #
    # test to create, rename, update, delete
    #

    'crud' : function(self)

        # create
        self.sync_direct('A',      'update', 'a.txt', '123')
        self.sync_direct('A',      'verify', 'a.txt', '123')
        self.sync_direct('server', 'verify', 'a.txt', '123')
        self.sync_direct('B',      'verify', 'a.txt', '123')

        # rename
        self.sync_direct('A',      'rename', 'a.txt', nil, 'b.txt')
        self.sync_direct('A',      'verify', 'b.txt', '123')
        self.sync_direct('server', 'verify', 'b.txt', '123')
        self.sync_direct('B',      'verify', 'b.txt', '123')

        # update
        self.sync_direct('B',      'update', 'b.txt', '456')
        self.sync_direct('B',      'verify', 'b.txt', '456')
        self.sync_direct('server', 'verify', 'b.txt', '456')
        self.sync_direct('A',      'verify', 'b.txt', '456')

        #delete
        self.sync_direct('A',      'delete', 'b.txt')
        self.sync_direct('A',      'verify', 'b.txt')
        self.sync_direct('server', 'verify', 'b.txt')
        self.sync_direct('B',      'verify', 'b.txt')

        # tell servers and client to exit
        self.direct(nil, 'A',      'die')
        self.direct(nil, 'B',      'die')
        self.direct(nil, 'server', 'die')

    end,

    # creates local file of random content, size in KB
    'create_local_file' : function(self, dir, name, size)
        sys.forkexec(true '/bin/dd', 'if=/dev/urandom', 'bs=1', 'count=' + size, 'of=' + dir +'/'+ name)
    end,

    'sync_direct' : function(self, whom, action, path, content, path2, size)

        title = action +' '+ path
        if path2 then
            title = title +' to '+ path2
        end

        self.direct(title, whom, action, ['path':path, 'content':content, 'path2':path2, 'size':size])

    end,


] + test_director


mesh = Mesh.init(director.id, host, port, [director])
director.launch(mesh)
