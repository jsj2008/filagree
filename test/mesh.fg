####### mesh.fg


Mesh = [


    'peers' : [], # maps id : socket
    'sreep' : [], # maps socket: id
    'seq'   : 0,


    'init' : function(self, id, address, port, mesh_subscribers)

        self.id = id
        self.address = address
        self.port = port
        self.ctx = mesh_subscribers or []

        return self

    end,


    'listen' : function(self)
        sys.listen(self.port, self)    # server listens for incoming socket connections
    end,


    'connect' : function(self)
        sys.connect(self.address, self.port, self)
    end,


    'connected' : function(self, socket)
        msg1 = ['event' : 'greet', 'from' : self.id] + self.greet()
        self.send(socket, msg1)
        for c in self.ctx
            c.connected(self, socket)
        end
    end,


    'disconnected' : function(self, socket)
        id = self.sreep[socket]
        self.handle_disconnect(id)
        self.peers[id] = self.sreep[socket] = nil

        sys.print('disconnected from ' + id)

        for c in self.ctx
            c.disconnected(self, socket)
        end
    end,


    'handle_message' : function(self, socket, msg5)

        if msg5.event == 'greet' then
            sys.print('connected to ' + msg5.from)
            self.peers[msg5.from] = socket
            self.sreep[socket] = msg5.from
        end
    end,


    'messaged' : function(self, socket, msg4)

        if (not msg4.to) or (msg4.to == self.id) # por moi

            #sys.print('message to ' + self.id + ' from ' + socket + ': ' + msg4.event)

            if not (response = self.handle_message(socket, msg4)) then
                for c in self.ctx
                    response = c.handle_message(socket, msg4)
                    if response then
                        mm2 = ['from' : self.id, 'seq' : msg4.seq] + response
                        self.send_to(msg4.from, mm2)
                        return
                    end
                end
            end

            if msg4.flood then
                self.broadcast(msg4, socket)
            end

        else # forward to recipient

            to = self.peers[msg4.to] # id -> socket
            if not to then
                sys.print('no peer ' + msg4.to)
            else
                self.send(to, msg4)
            end
        end

    end,


    'request' : function(self, to, msg)
        msg.seq = self.seq
        self.requests[self.seq] = msg
        self.send_to(to, msg)
    end,


    'send_to' : function(self, to, msg)

        msg.from = self.id
        msg.to = to
        to2 = self.peers[to] # id -> socket

        # if no direct connection, then send via 'server'
        if not to2 then
            if self.id != 'server' then
                to2 = self.peers['server']
            else
                sys.print('no peer ' + to)
            end
        end

        self.send(to2, msg)

    end,


    'send' : function(self, to, msg)
        #sys.print(self.id + ' send to ' + to + ': ' + msg.event)
        sys.send(to, msg)
    end,


    'broadcast' : function(self, msg6, except)
        if self.offline then
            return
        end
        msg6.flood = true
        msg6.from = msg6.from or self.id
        for socket in self.peers.vals where (socket != except)
            self.send(socket, msg6)
        end
    end,
]
